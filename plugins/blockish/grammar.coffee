###
I converted grammar.txt into javascript.
This file represents:
- Which elements are valid children of each element
- Which elements are optional
- The order (if there is any) the children must appear

Currently it just prints out all the valid children of each element.

This file will also need to:
- denote which HTML element corresponds to each cnxml one
- Distinguish between which "optional" elements should be included in the autogenerated template
  (In a para everything is optional but shouldn't be created when a new template is)
- A set of "rules" for dealing with malformed HTML (graceful degredation of content)

###

G = {}

# Optional elements that are auto-inserted when a new template is created
AUTO_INSERTED = [
#  'title', 'label',
  'caption',
  'problem', 'solution',
  'statement', 'proof',
  'item', 'para'
]

# A mapping of element name to its Rule tree
G.Rules = { }
G.Root = '_root'

populate = (elements, rule) ->
  # console.log elements
  for name in elements
    G.Rules[name] = rule

class Rule
  supports: (name) ->
    false
  children: () ->
    []
  templateChildren: () ->
    template = []
    for child in @children()
      if child in AUTO_INSERTED
        template.push child
    template

class Terminal extends Rule
  constructor: (@name) ->
  supports: (name) ->
    @name == name
  children: () ->
    [ @name ]
  isValid: (node) ->
    return @name == node.name
  consumeChildren: (childNodes) ->
    if childNodes.length != 0
      child = childNodes[0]
      if @name == child #PHIL .name
        # Check if it's children are valid
        # PHIL: Don't recursively consume children: rule = G.Rules[@name]
        # PHIL: Don't recursively consume children: rule.consumeChildren child.children
        childNodes.splice(0, 1) # PHIL: Don't recursively consume children: if child.children.length == 0

class Opt extends Terminal

class Or extends Rule
  constructor: (@rules) ->
    i = 0
    for rule in @rules
      if typeof rule == 'string'
        @rules[i] = new Terminal rule
      i += 1

  supports: (name) ->
    for rule in @rules
      if rule.supports name
        true
    false
  children: () ->
    ret = []
    for rule in @rules
      for prod in rule.children()
        ret.push prod
    ret
  consumeChildren: (childNodes) ->
    for child in childNodes
      for rule in @rules
        rule.consumeChildren childNodes

class Seq extends Or
  consumeChildren: (childNodes) ->
    # The loops are flipped from the "Or" rule so the sequence is preserved
    for rule in @rules
      for child in childNodes
        rule.consumeChildren childNodes

class One extends Opt
  constructor: (@rule) ->
    if typeof @rule == 'string'
      @rule = new Terminal @rule
  supports: (name) ->
    @rule.supports name
  children: () ->
    @rule.children()
  consumeChildren: (childNodes) ->
    # The loops are flipped from the "Or" rule so the sequence is preserved
    if not childNodes
      console.log ""
      console.log "SIOUSRER"
    for child in childNodes
      @rule.consumeChildren childNodes

class Zero extends One



# --------------------------------------
#  Meta-rules (containers for common rules)
# --------------------------------------
START =	new Or([ 'document' ])
LABEL_TITLE = new Seq([ new Opt( 'label' ), new Opt( 'title' ) ])

BLOCKISH = new Or([ 'quote', 'preformat', 'list' ])                     # these can be block or inline elements (depending on context)
STRICTLY_INLINE = new Or([ 'emphasis', 'term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code' ])
INLINE = new Or([ STRICTLY_INLINE, BLOCKISH ])                 # These are inline elements plus elements that appear both as blocks and inline
ANY_INLINE = new Or([ INLINE, 'cite-title', 'note', 'media', 'footnote', 'link', 'newline', 'space' ])
ONLY_STRICTLY_INLINE = ( STRICTLY_INLINE )
ONLY_INLINE = new One( INLINE )
ONLY_ANY_INLINE = new Zero( ANY_INLINE )

BLOCK = new Or([ BLOCKISH, 'div', 'definition', 'example', 'figure', 'code', 'note', 'media', 'table', 'rule', 'equation', 'exercise' ])
PARA_INLINE_BLOCK = new Or([ 'para', ANY_INLINE, BLOCK ]) # These are a choice: either the child is a block (or a para), or an unwrapped para (ANY_INLINE)
ANY_BLOCK = new One(new Or([ 'section', BLOCK, 'para' ]))             # block elements plus the loosest element, section (basically, anything goes!)
TITLE_BLOCK = new Seq([ LABEL_TITLE, ANY_BLOCK ])                # Same as above but the element can have a title/label

MEDIA_TEXT = new Seq([ new Opt( 'longdesc' ), new Zero( 'param' ), new Zero( new Or([ STRICTLY_INLINE, 'cite-title', 'preformat', 'quote', 'note', 'list', 'object', 'image', 'audio', 'video', 'java-applet', 'flash', 'labview', 'text', 'download' ]) ) ])

# --------------------------------------
# Rules that apply to several elements:
# --------------------------------------

populate([ 'quote', 'note', 'item' ],	                new Seq([ new Opt( 'label' ), ONLY_ANY_INLINE ]) )
populate([ 'div', 'preformat', 'footnote', 'meaning' ],	new Seq([ new Opt( 'title' ), new One( PARA_INLINE_BLOCK ) ]) )
populate([ 'quote', 'note', 'commentary' ],	          new Seq([ LABEL_TITLE, new One( PARA_INLINE_BLOCK ) ]) )
populate([ 'quote', 'preformat' ],	                  new One( new Or([ 'para', ONLY_INLINE ]) ) )
populate([ 'item', 'para' ],	                        ONLY_INLINE )
populate([ 'term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code', 'emphasis' ],	ONLY_STRICTLY_INLINE )
populate([ 'section', 'example', 'problem', 'solution', 'statement', 'proof' ],	TITLE_BLOCK )
populate([ 'preformat', 'title', 'label', 'span', 'cite', 'cite-title', 'link', 'emphasis', 'term', 'sub', 'sup', 'foreign', 'caption' ],	ONLY_ANY_INLINE )

# ----------------------------------------
# Rules that only apply to only 1 element
# ----------------------------------------

populate([ G.Root ], ANY_BLOCK)
populate([ 'glossary' ],	new One( 'definition' ) )
populate([ 'definition' ],	new Seq([ new Opt( 'label' ), 'term', new Or([ 'seealso', new One( 'meaning', new Zero( 'example' ) ), new Opt( 'seealso' ) ]) ]) )
populate([ 'seealso' ],	new Seq([ new Opt( 'label' ), new One( 'term' ) ]) )
populate([ 'list' ],	new Seq([ LABEL_TITLE, new One( 'item' ) ]) )
populate([ 'rule' ],	new Seq([ LABEL_TITLE, new One( 'statement' ), new One( new Or([ 'proof', 'example' ]) ) ]) )
# populate([ 'exercise' ],	new Seq([ LABEL_TITLE, new Or([ 'problem', new Zero( 'solution' ), new Zero( 'commentary' ) , 'item' ]) ]) )
populate([ 'exercise' ],	new Seq([ LABEL_TITLE, 'problem', new Zero( 'solution' ), new Zero( 'commentary' ) ]) )
populate([ 'figure' ],	new Seq([ LABEL_TITLE, new Or([ 'media',  'table',  'code',  new One( 'subfigure' ) ]), new Opt( 'caption' ) ]) )
populate([ 'subfigure' ],	new Seq([ LABEL_TITLE, new Or([ 'media', 'table', 'code' ]), new Opt( 'caption' ) ]) )

populate([ 'item' ],	new Seq([ new Opt( 'label' ), new Zero( PARA_INLINE_BLOCK ) ]) )
# populate([ 'para' ],	new Seq([ new Opt( 'title' ), new One ( new Or([ ANY_INLINE, BLOCK ])  ) ]) ) # Almost a PARA_INLINE_BLOCK+ except that nesting para's are not allowed
populate([ 'para' ],	new One ( new Or([ ANY_INLINE, BLOCK ])  ) ) # Almost a PARA_INLINE_BLOCK+ except that nesting para's are not allowed
populate([ 'code' ],	new One( ANY_INLINE ) )
populate([ 'code' ],	new Seq([ LABEL_TITLE, new One( ANY_INLINE ), new Opt( 'caption' ) ]) )
populate([ 'equation' ],	new Seq([ LABEL_TITLE, new Or([ 'media' ]) ]) )



# Figure out what each cnxml element maps to in HTML
G.Elements_INVERTED =
  body: [ G.Root ]
  div: [ 'note', 'div', 'footnote', 'meaning', 'commentary', 'section', 'example', 'exercise', 'problem', 'solution', 'statement', 'proof', 'code', 'rule', 'equation' ]
  span: [ 'preformat', 'term', 'foreign', 'cite', 'span', 'cite-title', 'caption', 'seealso', 'label' ]
  dl: ['glossary']
  dt: ['definition']
  a: ['link']
  p: ['para']
  sub: ['sub']
  sup: ['sup']
  em: ['emphasis']
  strong: ['emphasis'] # TODO: figure out how to deal with emphasis
  ul: ['list']
  ol: ['list']
  li: ['item']
  h1: ['title', 'label']
  figure: ['figure', 'subfigure']
G.Elements = {}
for key, values of G.Elements_INVERTED
  for value in values
    G.Elements[value] = key

G.AllElements = (x for x, _ of G.Rules)


# Given an HTML element look up 
htmlToElement = ($el) ->
  tag = $el.get(0).tagName.toLowerCase()
  if tag of G.Elements_INVERTED
    if G.Elements_INVERTED[tag].length == 1
      # Only one element maps to it. no need to check the class name
      G.Elements_INVERTED[tag][0]
    else
      # Match on class name
      for name in G.Elements_INVERTED[tag]
        return name if $el.hasClass name
  else
    console.log "Could not parse a #{tag}"
    null

# Builds a tree out of the HTML so we can validate the tag structure
class G.Node
  constructor: ($el, depth = -1, @name = null, @children = []) ->
    @parseHtml($el, depth) if $el
  parseHtml: (@$el, depth = -1) ->
    @name = htmlToElement @$el
    if @name
      if depth != 0
        for child in @$el.children()
          n = new G.Node()
          n.parseHtml $(child), (depth == -1 ? -1 : depth - 1)
          if n.name
            @children.push n

  # Checks if an element of type "name" can be inserted into the node
  allowsForA: (name) ->
    if @name and @children
      # Build up a list of just the names of child elements
      children = (child.name for child in @children)
      
      # Inject the element we want to test
      # HACK: for titles and labels inject them in the beginning
      switch name
        when 'title' then children.splice(0, 0, name)
        when 'label' then children.splice(0, 0, name)
        else children.push(name)
      G.Rules[@name].consumeChildren(children)
      children.length == 0
      

if window?
  window.Cnx = window.Cnx or { }
  window.Cnx.Grammar = G

else
  # Run the tests when run from the commandline
  console.log "---------------------------------------------"
  console.log "Which elements will be autogenerated (optional/required)"
  console.log "  when a new element of this type is created?"
  console.log "---------------------------------------------"
  for key, rule of G.Rules
    console.log "(Debug) Rule: #{key}: #{rule.templateChildren()}"

  console.log "---------------------------------------------"
  console.log "What are all the possible children of this element?"
  console.log "---------------------------------------------"
  for key, rule of G.Rules
    console.log "(Debug) Rule: #{key}: #{rule.children()}"
  
  console.log "---------------------------------------------"
  console.log "Some unit tests on the grammar."
  console.log "---------------------------------------------"
  n = new G.Node('list', [ new G.Node('item'), new G.Node('item') ])
  rule = G.Rules[n.name]
  rule.consumeChildren n.children
  console.log "Expected: 0   Got: #{ n.children.length }"

  n = new G.Node('list', [ new G.Node('item'), new G.Node('term') ])
  rule = G.Rules[n.name]
  rule.consumeChildren n.children
  console.log "Expected: 1   Got: #{ n.children.length }"


  console.log "---------------------------------------------"
  console.log "Which elements can be upconverted into other elements"
  console.log "  (assuming all of their child nodes are populated)"
  console.log "---------------------------------------------"
  # For example:
  # A section with just a title and a para should be able to be converted into:
  # - a note
  # - an example
  # - anything else that:
  #   1. is valid in the same context
  #   2. supports the same, already populated children
  #
  # As another example, a section with a title and a subsection could _not_
  #   be upconverted to a note. 
  for element in G.AllElements
    #console.log "#{element}.children = #{G.Rules[element].children()}"
    for el2 in G.AllElements
      if element != el2
        # Compare all the possiblle children.
        # If one is a subset of the other record that
        flag = false
        for child in G.Rules[element].children()
          if child not in G.Rules[el2].children()
            flag = true
        if not flag
          invalidParents = []
          validParents = []
          for parent in G.AllElements
            if element in G.Rules[parent].children()
              if el2 in G.Rules[parent].children()
                validParents.push(parent)
              else
                invalidParents.push(parent)
          if validParents.length > 0
            if invalidParents.length > 0
              if (validParents.length - invalidParents.length >= 0 and invalidParents.length > 0) or validParents.length == 0
                console.log "#{element} > #{el2} except when in #{invalidParents}"
              else
                console.log "#{element} > #{el2} ONLY when in #{validParents}"
            else
              console.log "#{element} > #{el2}"
        #if flag
        #  console.log "#{element} !> #{el2}"
